# Java内存模型 #

摩尔定律：

阿姆达尔（Amdahl）定律：

阿姆达尔定律通过系统中并行化与串行化的比重来描述多处理器系统能获得的运算加速能力，摩尔定律则用于描述处理器晶体管数量与运行效率之间的发展关系。这两个定律的更替代表了近年来硬件发展从追求处理器频率到追求多核心并行处理的发展过程。

并发应用场景：

+ 充分利用计算机处理器的能力。计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上
+ 一个服务端同时对多个客户端提供服务。每秒事务处理数（Transactions Per Second，TPS）是衡量一个服务性能高低好坏最重要的指标之一，代表着一秒内服务端平均能响应额请求总数

并发带来的问题：

+ 高速缓存引入的缓存一致性（Cache Coherence）问题。高速缓存（Cache）作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器无须等待缓慢的内存读写，解决了处理器与内存的速度矛盾。但是引入了缓存一致问题，在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
+ 处理器对输入代码进行乱序执行（Out-Of-Order Execution）优化，充分利用计算器内部的运算单元。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致
+ Java虚拟机即时编译器的指令重排序（Instruction Reorder）优化

Java内存模型（Java Memory Model，JMM）是Java虚拟机定义的一种内存模型，用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与Java编程中的变量有所区别，包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示：

从变量、主内存和工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高度缓存中，因为程序运行时主要访问读写的是工作内存。

## 内存操作 ##

JMM定义了8种具有原子性的操作来完成主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节。

+ lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
+ unlock（解锁）：作用于内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
+ read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
+ load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
+ use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
+ assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
+ store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
+ write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

JMM还规定在执行上述8中基本操作时必须满足如下规则：

+ 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现
+ 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
+ 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中
+ 一个新的变量只能在内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作
+ 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
+ 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值
+ 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量
+ 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）

JMM中定义的8中内存操作以及上述规则限定，再加上对volatile型变量的特殊规则，完全确定了Java程序中哪些内存访问操作在并发下是安全的。

**对于long和double型变量的特殊规则** JMM要求这8种内存操作都具有原子性，但是对于64位的数据类型（long和double），特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，即long和double的非原子性协定。如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。但是，JMM允许并强烈建议虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用计算机几乎都选择把64位数据的读写操作实现位原子操作。

## volatile ##

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。

volatile具有两种语义，一是可见性，一是禁止指令重排序优化。

可见性是指当一个变量定义为volatile后，如果一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即得知的，而普通变量就不能做到这一点。但请注意，volatile变量在各个线程的工作内存中不存在一致性问题，但是Java里面运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。

volatile型变量赋值后多执行一个`lock addl $0x0, (%esp)`操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置）。`addl $0x0, (%esp)`（把ESP寄存器的值加0）是一个空操作，关键在于lock前缀（IA32规定lock前缀不允许配合nop指令使用），它的作用是使得本CPU的Cache写入内存，该写入动作也会引起别的CPU或者别的内核无效化其Cache，所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。另外，从硬件架构上讲，指令重排序是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理，但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果，即在本CPU内，重排序看起来依然是有序的，称为“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。因此，`lock addl $0x0, (%esp)`指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性：

+ 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
+ 变量不需要与其他的状态变量共同参与不变约束

volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

**volatile变量的特殊规则** 假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：

+ 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做修改后的值）
+ 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）
+ 假定动作A是线程T对变量实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）
