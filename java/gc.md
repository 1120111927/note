# Java 内存区域与垃圾收集 #

Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。

## Java运行时数据区域 ##

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：方法区（method area）、堆（heap）、程序计数器（program counter register）、虚拟机栈（vm stack）、本地方法栈（native method stack）。其中，方法区和堆为所有线程共享，生命周期与虚拟机进程相同，程序计数器、虚拟机栈和本地方法栈是线程私有的，生命周期与线程相同。

**程序计数器**是一块较小的内存空间，如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined），此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

**虚拟机栈**描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。这个区域可能发生两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

**本地方法栈**与虚拟机栈作用相似，只不过虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

**Java堆**是Java虚拟机所管理的最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，即所有的对象实例以及数组都要在堆上分配。Java堆是垃圾收集器管理的主要区域，从内存回收角度看，对于分代收集算法，Java堆还可以细分为新生代和老年代，其中，新生代又可以细分为Eden空间、From Survivor空间、To Survivor空间。从内存分配角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。Jva堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。这个内存区域可能抛出OutOfMemoryError异常，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

**方法区**用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据，对于HotSpot虚拟机，方法区也成为永久代（Permanent Generation），在JDK 1.7的HotSpot中，把原本放在永久代的字符串常量池移出。Java虚拟机规范堆方法区的限制非常宽松，不需要连续的内存和可以选择固定大小或者可扩展，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。这个区域可能抛出OutOfMemoryError异常，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

运行时常量池（runtime constant pool）是方法区的一部分，一般用于存储Class文件中描述的符号引用和翻译出来的直接引用，另外，运行时常量池具备动态性，运行期间也可以将新的常量放入池中，比如String类的`intern()`方法。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

直接内存（direct memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。JDK 1.4新加入了NIO类，引入了一种基于通道（channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能哎一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是受到本机总内存大小以及处理器寻址空间的限制，当动态扩展且无法申请到足够的内存时，就会抛出OutOfMemeoryError。

## 垃圾收集 ##

垃圾收集（Garbge Collection，GC）的主要目标区域是Java堆和方法区。

判断对象是否存活有两种算法：

+ 引用计数算法（Reference Counting）：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。引用计数算法实现简单，判定效率也很高，但是很难解决对象之间相互循环引用的问题
+ 可达性分析算法（Reachability Analysis）：通过一系列GC Roots对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达）时，则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括下面几种：
  + 虚拟机栈（栈帧中的本地变量表）中引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中JNI（即Native方法）引用的对象

在JDK 1.2之前，Java中的引用定义为：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

在JDK 1.2之后，Java将引用分为强引用、软引用、弱引用和虚引用，这4种引用强度依次减弱：

+ 强引用（Strong Reference）：指在程序代码之中普遍存在的，类似`Object obj = new Object()`这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
+ 软引用（Soft Reference）：用来描述一些还有用但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常，JDk 1.2之后提供了SoftReference类来实现软引用
+ 弱引用（Weak Reference）：用来描述非必需对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，JDK 1.2之后提供了WeakReference类来实现弱引用
+ 虚引用（Phantom Reference）：也称为幽灵引用或者幻影引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，JDK 1.2之后提供了Phantom Reference类来实现虚引用

要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。执行是指虚拟机会触发这个方法，但是不承诺会等待它运行结束。finalize()方法是对象逃脱死亡命运的最后一个机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己（只要重新和引用链上的任何一个对象建立关联即可），那在第二次标记时它将被移除出即将回收的集合。如果对象这时候还没有逃脱，基本上就真的被回收了。

注意，**任何一个对象的finalize()方法都只会被系统自动调用一次**，如果对象面临下一次回收，它的finalize()方法不会被再次执行。finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，而关闭外部资源之类的工作使用try-finally或者其他方式都可以做得更好、更及时，所以不建议使用finalize()方法。

Java虚拟机规范中不要求虚拟机在方法区实现垃圾收集。而且在方法区中进行垃圾收集的性价比一般比较低（远远低于新生代70%~95%的可回收空间）。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。废弃常量是说没有任何对象引用这个常量，且其他地方也没有引用这个字面量。无用类则需要同时满足下面3个条件：

+ 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
+ 加载该类的ClassLoader已经被回收
+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

HotSpot虚拟机提供了`-Xnoclassgc`参数控制对类是否进行回收。使用`-verbose:class`以及`-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`可以查看类加载和卸载信息。

### 垃圾收集算法 ###

#### 标记-清除算法 ####

标记-清除（Mark-Sweep）算法是最基础的收集算法，算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。


