# Java 内存区域与垃圾收集 #

## Java运行时数据区域 ##

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域：方法区（method area）、堆（heap）、程序计数器（program counter register）、虚拟机栈（vm stack）、本地方法栈（native method stack）。其中，方法区和堆为所有线程共享，生命周期与虚拟机进程相同，程序计数器、虚拟机栈和本地方法栈是线程私有的，生命周期与线程相同。

**程序计数器**是一块较小的内存空间，如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined），此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

**虚拟机栈**描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。这个区域可能发生两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，且扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

**本地方法栈**与虚拟机栈作用相似，只不过虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

**Java堆**是Java虚拟机所管理的最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，唯一目的就是存放对象实例，即所有的对象实例以及数组都要在堆上分配。Java堆是垃圾收集器管理的主要区域，从内存回收角度看，对于分代收集算法，Java堆还可以细分为新生代和老年代，其中，新生代又可以细分为Eden空间、From Survivor空间、To Survivor空间。从内存分配角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。Jva堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。这个内存区域可能抛出OutOfMemoryError异常，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

**方法区**用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据，对于HotSpot虚拟机，方法区也成为永久代（Permanent Generation），在JDK 1.7的HotSpot中，把原本放在永久代的字符串常量池移出。Java虚拟机规范堆方法区的限制非常宽松，不需要连续的内存和可以选择固定大小或者可扩展，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。这个区域可能抛出OutOfMemoryError异常，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
