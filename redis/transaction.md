# Redis #

## 事务（transaction） ##

```c
def execute_transaction():

    # 创建空白的回复队列
    reply_queue = []

    # 取出事务队列里的所有命令、参数和参数数量
    for cmd, argv, argc in client.transaction_queue:

        # 执行命令，并取得命令的返回值
        reply = execute_redis_command(cmd, argv, argc)

        # 将返回值追加到回复队列末尾
        reply_queue.append(reply)

    # 清除客户端的事务状态
    clear_transaction_state(client)

    # 清空事务队列
    clear_transaction_queue(client)

    # 将事务的执行结果返回给客户端
    send_reply_to_client(client, reply_queue)
```

Redis通过MULTI、DISCARD、EXEC和WATCH四个命令来实现事务功能。

Redis事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制，并且事务在执行的期间不会主动中断——服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。

Redis事务先以MULTI开始一个事务，然后将多个命令入队到事务中，最后由EXEC命令触发事务，一并执行事务中的所有命令。

一个事务从开始到执行会经历以下三个阶段：

1. 开始事务：MULTI命令的执行标记着事务的开始。MULTI命令将客户端的REDIS_MULTI选项打开，让客户端从非事务状态切换到事务状态。
2. 命令入队：当客户端处于非事务状态下时，所有发送给服务器端的命令都会立即被服务器执行。但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令（除了EXEC、DISCARD、MULTI和WATCH）时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队。EXEC、DISCARD、MULTI和WATCH这四个命令从客户端发送到服务器时，总是直接被服务器执行。
3. 执行事务：如果客户端正处于事务状态，那么当EXEC命令执行时，服务器根据客户端所保存的事务队列，以先进先出（FIFO）的方式执行事务队列中的命令：最先入队的命令最先执行，而最后入队的命令最后执行。

事务队列是一个数组，每个数组项包含三个属性：

+ 要执行的命令（cmd）
+ 命令的参数（argv）
+ 参数的个数（argc）

执行事务中的命令所得的结果会以FIFO的顺序保存到一个回复队列中。当事务队列里的所有命令被执行完之后，EXEC命令会将回复队列作为自己的执行结果返回给客户端，客户端从事务状态返回到非事务状态，至此，事务执行完毕。

DISCARD命令用于取消一个事务，它清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回字符串OK给客户端，说明事务已被取消。

WATCH命令用于在事务开始之前监视任意数量的键：当调用EXEC命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务就不再执行，直接返回失败。

注意，Redis事务是不可嵌套的，当客户端已经处于事务状态，而客户端又再向服务器发送MULTI时，服务器只是简单地向客户端发送一个错误，然后继续等待其他命令的入队，MULTI命令的发送不会造成整个事务的失败，也不会修改事务队列中已有的数据。WATCH只能在客户端进入事务状态之前执行，在事务状态下发送WATCH命令会引发一个错误，但不会造成整个事务的失败，也不会修改事务队列中已有的数据。

传统的关系式数据库中，常常用ACID性质来检验事务功能的安全性。

+ A：Atomicity，原子性
+ C：Consistency，一致性
+ I：Isolation，隔离性
+ D：Durability，持久性

Redis事务保证了一致性和隔离性，但并不保证原子性和持久性。

## Watch的实现 ##
