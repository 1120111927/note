# 散列表（HashTable） #

散列表用的是数组支持按照下标随机访问数据的特性，插入元素时，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。所以散列表其实就是数组的一种扩展，由数组演化而来。

## 散列函数 ##

`hash(key)`将键转化为数组的索引。

均匀散列假设是使用散列时的一个重要假设，是指使用的散列函数能够均匀并独立地将所有的键散布于0到M-1之间。

散列函数设计的基本要求：

1. 散列函数计算得到的散列值是一个非负整数
2. 如果key1 = key2，那么hash(key1) = hash(key2)（一致性）
3. 如果key1 != key2，那么hash(key1) != hash(key2)

另外，散列函数要计算简便（高效性），散列函数生成的值要尽可能随机并且均匀分布（均匀性）。保证均匀性的最好方法就是保证键的每一位都在散列值的计算中起相同的作用。

设计散列函数的方法：数据分析法、直接寻址法、平方取中法、折叠法、随机数法。

### 正整数 ###

将正整数散列最常用方法是除留余数法。选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数，将键散布在0到M-1的范围内。如果M不是素数，可能无法利用键中包含的所有信息。

### 浮点数 ###

如果键是0到1之间的实数，可以将它乘以M并四舍五入得到一个0至M-1之间的索引值。使用该方法时，键的高位起的作用更大，最低位对散列结果没有影响。

另外可以将键表示为二进制数然后再使用除留余数法。

### 字符串 ###

将字符串当作大整数，使用除留余数法：

```Java
int hash = 0;
for (int i = 0; i < s.length(); i++) {
    hash = (R * hash + s.charAt(i)) % M;
}
```

如果R比任何字符的值都打，这种计算相当于将字符串当作一个N位的R进制值，将它除以M并取余。

## 散列冲突 ##

两个或多个键的散列值相同时就会发生散列冲突。处理散列冲突有两种方法：开放寻址法和链表法。

### 开放寻址法 ###

如果出现了散列冲突，就重新探测一个空闲位置，将其插入。常用的探测方法有线性探测、二次探测、双重散列。

线性探测的过程为：当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止；在散列表中查找数据时，先通过散列函数求出要查找元素的键对应的散列值，然后比较数组中下标为散列值的数据和要查找的数据，如果相等，则找到数据，否则顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。删除数据时，可以将删除的元素标记为deleted，当线性探测查找时，遇到标记为deleted的空间不是停下来二是继续往下探测。

二次探测是指每次探测的步长变成原来的二次方，即探测下标序列为`hash(key)+0, hash(key)+1^2, hash(key)+2^2, ...`。

双重散列是指使用一组散列函数`hash1(key), hash2(key), hash3(key), ...`先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

### 链表法 ###

链表法是一种更加常用的散列冲突解决方法，在散列表中，每个桶（bucket）或者槽（slot）会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。

插入数据的时候，通过散列函数计算出对应的散列槽位，将其插入到对应链表中。

查找数据的时候，通过散列函数计算出对应的散列槽位，然后在链表中查找和键相同的数据。

删除数据的时候，查找该数据并从链表中删除。

## 装载因子 ##

装载因子用于表示散列表的性能。其计算公式为：

`散列表的装载因子 = 填入表中的元素个数 / 散列表的长度`

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

## 哈希算法 ##

哈希算法将任意长度的二进制值串映射为固定长度的二进制值串。

哈希算法要求：

1. 从哈希值不能反向推导出原始数据
2. 对输入数据非常敏感，即时原始数据只修改了一位，得到的哈希值也大不相同
3. 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小
4. 哈希算法的执行效率要尽量高效

哈希算法应用：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。

## 应用举例 ##

### Java HashMap实现 ###

### LRU缓存淘汰算法 ###

### Redis有序集合 ###

### Java LinkedHashMap ###
